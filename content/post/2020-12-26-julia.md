---
title: Moving to Julia
subtitle: Porting an entire project from Python to Julia
date: 2020-12-26
---

About a month ago I decided to port the entire code-base of my Reinforcement
Learning project from Python 3.8 to Julia 1.0.4, about which I knew next to
nothing.

## Why did I decide to port an entire code-base to Julia?

I wanted to see what Julia is about.

## How long did it take?

It is really easy to use Julia. Porting everything took me about three days,
and less than a week to be certain everything was working correctly.

## What did I do?

I am working on a Reinforcement Learning (RL) project using the traditional
robotics libraries: Pybullet and OpenAI Gym. Those libraries are used to
benchmark RL algorithms, so my code needs to be able to interact with them
during run-time.

According to a brief internet search, the `Pycall.jl` Julia package allows
calling Python code from Julia, which meant that --in principle-- I could
rewrite everything in Julia without loosing the ability to interact with
the Python libraries I absolutely needed to use.

Below is a summary of what I did to replace the code I did not write:

| Python  | Julia |
|---------|-------|
| Pybullet| I used the wonderful `PyCall.jl` Julia package, which lets me call Python programs and libraries from Julia. So I get to use Pybullet almost --almost-- as if it were a Julia library. |
| OpenAI Gym | Exactly the same as with Pybullet. |
| Pytorch | Implemented Artificial Neural Networks from scratch in Julia. As am I using a Genetic Algorithm to optimize the weights, implementation is basically just multiplication of matrices. |
| Networkx   | I only used Networkx to plot some simple graphs, so `GraphRecipes.jl` did the trick. |
| Matplotlib | I replaced Matplotlib with `Plots.jl`.|

As for the code I did write, porting was smooth. I spent about a day reading
basic Julia documentation, after which I began to "get Julia". Fortunately my
current coding habits include constantly cleaning code that is unused, so there
was not too much code to be ported: **there are 1192 Julia lines in total**.

## Conclusions

While the initial porting took about a week, I write this one month after
I began using Julia.

- Julia is fast. Once the code is running it really is fast. Speed was not
	the main reason I decided to port to Julia (it was curiosity), but it
	is fast.

- There is a lot of latency in running Julia code. It takes literally minutes
	to get from `$ julia Main.jl` to the first line of code. According to some
	Github issues there has been a lot of progress in this regard. **Julia
	is not a scripting language**.

- The most interesting part of porting was replacing the `multiprocessing.Pool`
	and `concurrent.futures` Python modules. The `SharedArray` data structure,
	the `@sync`, `Threads.@threads` macros and the `Distributed` Julia module are
	some really cool features.

- It seems that you cannot bypass Python's Global Interpreter Lock by
	threading `Pycall` calls, so you are stuck with multiprocessing if you
	need to fully leverage multi-core architectures with Python code.

- Writing in Julia --with no traces of Object Oriented Programming-- feels
	great. 
